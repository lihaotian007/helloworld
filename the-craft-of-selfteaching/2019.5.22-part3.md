# part3

## 战胜难点

所有的难点，事实上都可以被拆解成更小的单元，而后在逐一突破的时候，就没那么难了。逐一突破全部完成之后，再拼起来重新审视的时候就会发现那所谓的难常常只不过是错觉、幻觉而已 ———— 我把它称为**困难幻觉**

把一切都当做手艺看的好处之一就是 ———— 心态平和，因为你知道那不靠天分和智商，它靠的是另外几件事：不混时间、刻意思考、以及刻意练习 ———— 其实吧，老祖宗早就有总结：

> 天下无难事，只怕**有心人**

大家都是人，咋可能没**心**呢？想成为有心人，其实无非是学会拆解后逐一突破，就这么简单。

> 无论学什么都一样，难的部分不学会，就等于整个没学 ———— 仅因为不够全面

有什么必要干前功尽弃的事情呢？要么干脆别学算了，何必把自己搞成一个半吊子？ ———— 可惜，这偏偏是绝大多数人的习惯，学什么都一样，容易的部分糊弄糊弄，困难的部分直接回避……其实所有焦虑，都是这样在许多年前被埋下，在许多年后生根发芽、茂盛发达的 ———— 你想想看是不是如此？

虽然别人认为难，你刚开始也会有这样的错觉，但只要你开始施展“读不懂也要读完，读完之后再读很多遍”的手段，并且还“不断自己动手归纳总结整理”，你就会“发现”，其实没什么大不了的，甚至你会有错觉：

> “突然”之间一切都明了了！

对很多人来说，阅读的难点在于起初的时候它总是显得异常枯燥

刚识字、刚上学的时候，由于理解能力有限，又由于年龄的关系于是耐心有限，所以，那是需要老师耐心陪伴、悉心引导。这就好像小朋友刚出生的时候，没有牙齿，所以只能喝奶差不多……然而，到了一定程度一定要断奶，是不是？可绝大多数人的实际情况却是，小学的时候爱上了“奶嘴”，而后一生没有奶嘴就吃不下任何东西。

开始“自学”的活动，本质上看和断奶是一回事。

> * 知识就是知识，它没有任何义务去具备幽默生动的属性；
> * 手艺就是手艺，它没有任何义务去具备有趣欢乐的属性；

所以，有自学能力的人，不怕枯燥 ———— 因为那本来就理应是枯燥的。就好像人生本无意义，有意义的人生都是自己活出来的一样，有意义的只是都是自己用出来的 ———— 对不用它的人、用不上它的人来说，只能也只剩下无法容忍的枯燥。

## 类 ———— 面向对象编程

面向对象编程（OOP），是一种编程的范式（paradigm），或者说是一种方法论（Methodology）

### 基本术语

> 对象、封装、界面；抽象、属性、方法；类、子类、继承、实例

面向对象编程，是使用**对象**（Objects）作为核心的编程方式。进而就可以把对象（Objects）的数据和运算过程**封装**（Encapsulate）在内部，而外部仅能根据事先设计好的**界面**（interface）与之沟通

在程序设计过程中，我们常常需要对标现实世界创造对象，这时候我们用的最直接手段就是**抽象**（Abstract）。被抽象保留下来的“必要特征”，叫做对象的**属性**（Attributes），进而，这些抽象的对象既然是一种映射，它们实际上也能做一些抽象过后被保留下来的“必要的行为”，这些叫做对象的**方法**（Methods）。

从另外一个方面来看，在设计复杂对象的时候，抽象到极致是一种必要

所以，当我们在程序里创建对象的时候，做法常常是

> * 先创建最抽象的**类**（Class）
> * 然后再创建**子类**（Subclss)

在OOP中这叫**继承**（inheritance）关系

当我们创建好一个类之后，就可以根据它创建它的许多**实例**（Instance）

在英文世界里，对象和类经常被通用。但其实只是视角不同

> * 你创造了一个类（Class），这时候你是创作者，从你眼里望过去，那就是个**类（Class）**；
> * 而后你根据这个类的定义，创建了很多实例（Instances）；
> * 接下来一旦你开始使用这些实例的时候，你就成了使用者，从使用者角度望过去，手里正在操作的，就是各种**对象（Objects）**……

最后，补充一下，不要误以为所有的 classes 都是对事物（即，名词）的映射 ———— 虽然大多数情况下确实如此

## 类 ———— Python的实现

### Defining Class

在class的代码中如果定义了`__init__()`函数，那么系统就会将它当作用来Instance在创建后被初始化的函数。这个函数的名称是强制指定的，初始化函数必须使用这个名称；注意`init`两端各有两个下划线`_`。

`self`是一个变量，跟程序中其他变量的区别在于，它是一个系统默认可识别的变量，用来指代将来用这个Class创建的Instance（类似于c++中的`this`）

### Inheritance

类名后面的圆括号中，写的是所Inheritance的Parent Class。当我们创建一个Inherited Class的时候，可以重写（Overriding）Parent Class中的Mathods。

### Inspecting A Class

当我们作为用户想了解一个Class的Interface，即，它的Attributes和Methods的时候，常用的有三种方式：

* help(object)
* dir(object)
* object.__dict__

### Scope

私有变量：变量名前面加上`一个以上`下划线的话，那么该变量是“私有变量”，不能被外部引用。而按照Python的惯例，我们会使用两个下划线起始，去命名私有变量

1、非私有变量：可以在class/object外调用，但需要使用`类名.属性名`或者`对象名.属性名`使用
2、私有变量：不能在class/object外调用。
3、函数外定义的私有变量：函数内调用需要使用`类名.属性名`或者`self.属性名`使用，后者需要在有self传递时才能使用。

> * self.属性名 - 总是读取类中属性的初始值，即时后面发生了改变
> * 类名.属性名 - 读取该属性的当前值

### Encapsulation

当我们不想让一个属性在外部进行修改的时候，可以把它写作一个“私有变量”。如果这个时候我们想要让外部获取它的值则需要通过一个method去实现

但外部访问的时候也只能通过`self/类名.函数名()`来访问，如果我们想要让外部可以通过`self/类名.函数名`来访问的话可以在定义函数的时候在函数名前面加上：

> * @property

于此相对，如果你希望某个“私有变量”，可以在外部赋值，那么只要在对应的函数前面加上：

> * @property.setter

## 函数工具

装饰器、迭代器、生成器 - DIG（Decorator, Iterator, Generator）

### Iterator

我们见过Python中的所有容器，都是可迭代的 ———— 准确的讲，是可以通过迭代遍历每一个元素：

> * `iter()`函数，可以将**可迭代对象（lterable）**转换成**迭代器（Iterator）**
> * `next()`函数，可以对Iterator进行迭代，越界使用会触发`StopIteration`错误

**迭代器是一个object**, 所以, 写迭代器的时候写的是Class

```python
def __iter__(self):
    return self
```

这两句是约定俗成的写法，写上他们这个类就会被识别为 Iterator 类型。而后再有`__next__(self)`的话，就是一个完整的迭代器了

### Generator

```python
def counter(start, stop):
    while start <= stop:
        yield start
        start += 1
for i in counter(101, 105):
    print(i)
```

这里的关键在于`yield`这个语句.`yield`相比于`return`最大的区别在于 ———— 在`yield`之后的语句依然会被执行，而`return`之后的语句会被忽略

生成器函数在被next()调用后，执行到`yield`生成一个返回值，然后继续执行next()外部剩余的语句；下次再被next()调用的时候，从上次生成返回值的`yield`语句处继续执行

以下为生成器表达式：

even = (e for e in range(10) if not e % 2) - **生成器表达式必须在括号内使用，包括函数的参数括号**

> * `()` - 用生成器创建迭代器
> * `[]` - 用生成器创建列表
> * `{}` - 用生成器创建集合

### Decoratar

**函数本身也是对象** ———— 即，Python定义的某个 Class 的一个 Instance。于是函数本身其实可以和其他数据类型一样，作为其他函数的参数或者返回值

> 用return语句返回`函数调用`和`函数本身`是不一样的 - 函数调用：函数名() | 函数本身：函数名

Python提供了一种**针对于函数的操作符**：@ 。被 @ 调用的函数叫做decoratar，其作用如下：

```Python
def a_decorator(func):
    def wrapper():
        print('We can do sth. before calling a_func...')
        func()
        print('... and we can do sth. after it was called...')
    return wrapper

@a_decorator
def a_func():
    print("Hi, I'm a_func!")

a_func()
```

> **@a_decorator 等价于 a_func = a_decorator(a_func)**

`@a_decorator`就是在用a_decorator的调用结果替换原来的函数。以后调用a_func()的时候，就会调用a_decorator的返回值，而a_decorator此时已经执行完毕了

当然，可以给一个函数写多个decorator，执行的顺序是`“自下而上”|“自里向外”`

当被装饰的函数有参数的时候，需要在装饰器内部进行修改 ———— 则参数列表调整为：(*args, **kwargs)

Decorator 最常用的场景是什么呢？**`最常用的场景就是用来改变其他函数的行为`**

## 正则表达式

> 规则表达式（Regular Expressions, 通常缩写为 Regex）是最强大且不可或缺的文本处理工具 ———— 它的用处就是在文本中扫描/`搜索`（Scan/Search）与某一`规则`（pattern）`匹配`（match，即，与规则一致）的所有实例，并且还可以按照规则`捕获`（capture）其中的部分或者全部，对它们进行`替换`（Replace）。

**有时，使用 Regex 并不是为了Replace，而是为了检查格式**，比如，可以用 Regex 检查用户输入的密码是否过于简单（全部是数字），比如可以用来验证用户输入的电话号码、证件号码是否符合特定格式等等。

另外，自学的过程中，想尽一切办法把一切术语用简单直白的“人话”重新表述，是特别有效的促进进步的行为模式

### 优先级

| 排列 |         原子与操作符优先级      |（从高到低）|
|---|-----------------------------------|------------------------|
| 1 | 转义符号 (Escaping Symbol)               | `\` |
| 2 | 分组、捕获 (Grouping or Capturing)                          | `(...)` `(?:...)` `(?=...)` `(?!...)` `(?<=...)` `(?<!...)`     |
| 3 | 数量 (Quantifiers)      | `a*` `a+` `a?` `a{n, m}` |
| 4 | 序列与定位（Sequence and Anchor）| `abc` `^` `$` `\b` `\B`               |
| 5 | 或（Alternation）| `a | b | c`                   |
| 6 | 原子 (Atoms)                 | `a` `[^abc]` `\t` `\r` `\n` `\d` `\D` `\s` `\S` `\w` `\W` `.` |

### 原子

在 Regex 的 Pattern中，操作元，即，被运算的“值”，被称为原子（Atom）。

**本义字符**：最基本的原子就是本意字符，它们都是单个字符，本义字符所代表的的就是字面值

> * `a-z`
> * `A-Z`
> * `0-9`
> * `_`

以下字符在 Regex 中都有特殊含义：

> `\` `+` `*` `.` `?` `-` `^` `$` `|` `(` `)` `[` `]` `{` `}` `<` `>`

当你在写 Regex 的时候，如果你要搜索的字符不是本意字符，而是以上这些特殊字符时，建议都直接加上转义符号`\`来表示 ———— 这对初学者来说可能是最安全的策略

**集合原子**：集合原子还是原子，标示集合原子，使用方括号`[]`。`[abc]`的意思是说，" `a` or `b` or `c` ",即，`abc`中任意一个字符（比如`beg[iau]n`能够代表begin、began，以及begun。

在`[]`中我们可以使用两个操作符：`-`（区间）和 `^`（非）

> 在一个集合原子中，`^`符号只能用一次，只能紧跟在`[`之后。否则不起作用。

**类别原子**：类别原子，是指那些能够代表"一类字符"的原子，它们都得使用转义符号再加上另外一个符号表达，包括：

> `\d` 任意数字；等价于 `[0-9]`
> `\D` 任意非数字；等价于`[^0-9]`
> `\w` 任意本义字符；等价于`[a-zA-Z0-9_]`
> `\W` 任意非本义字符；等价于`[^a-zA-Z0-9_]`
> `\s` 任意空白；相当于`[ \f\n\r\t\v]`（方括号内第一个字符为空格符号）
> `\S` 任意非空白；相当于`[^ \f\n\r\t\v]`（紧随`^`之后的是空格符号）
> `.`  除`\r` `\n` 之外的任意字符；相当于 `[^\r\n]` - 即，通配符

* 其中`d/D` - digits、`w/W` - word characters、`s/S` - spaces

* 其中`\f`是分页符（flip)、`\n` `\r`是换行符(new line、return）、`\t`是制表符（tab)、`\v`是纵向制表符(vertical tab)

**边界原子**：我们可以用边界原子指定边界。也可以称作“定位操作符”。

> * `^`  匹配被搜索字符串的开始位置 - Python中被`\A`替代
> * `$`  匹配被搜索字符串的结束位置 - Python中被`\Z`替代
> * `\b` 匹配**单词**的边界（不可以出现在单词的开始，可以出现在单词的结束）
> * `\B` 匹配非**单词**的边界（包括单词的开始）

**组合原子**：我们可以用`()`将多个单字符原子组合成一个原子 ———— 这么做的结果是，`()`内的字符串将被当做一整个原子，可以被随后我们要讲解的数量操作符操作。

`()`操作符的两个功能：组合、捕获

需要注意以下区别：

> * `er`，两个原子，'e'和随后的'r'
> * `[er]`，一个原子，'e'或者'r'
> * `(er)`，一个原子，'er'

### 数量操作符

数量操作符有：`+`、`？`、`*`、`{n,m}`

数量操作符均是用来限定位于他们`之前`的原子允许出现的个数；不加数量操作符限定则代表出现且仅出现一次

> * `+` 代表前面的原子必须`至少`出现一次，即：`出现次数 ≧ 1`
> * `?` 代表前面的原子`最多`可以出现一次，即：`0 ≦ 出现次数 ≦ 1`
> * `*` 代表前面的原子可以不出现，也可以出现一次或多次，即：`出现次数 ≧ 0`
> * `{n,m}` 代表前面的原子出现最少`n`次，最多`m`次，即：`n ≦ 出现次数 ≦ m`（`{n}` 代表之前的原子出现确定的 `n` 次）

### 或操作符 `|`

或操作符`|`，是所有操作符中优先级最低的，但高于原子。故`'begin|began|begun'`能够匹配 `begin` 或 `began` 或 `begun`

> **注意：**中括号（`[]`）中的 `|` 及`()`不被当做特殊符号，而是被当做符号本身，并无'或'及'分组'的含义。

### 匹配并捕获

**捕获（Capture）**，使用的是圆括号`（）`。使用圆括号得到的匹配的值被暂存成一个带有索引的列表，第一个是`$1`、第二个是`$2`……以此类推。随后，我们可以在替换的过程中使用`$1` `$2`中所保存的值

在Python语言中调用 `re` 模块之后，在 `re.sub()` 中调用被匹配的值，用的索引方法是 `\1` `\2` …… 以此类推

> 如果使用圆括号的目的只是分组，而非捕获，那么就在圆括号内最开头加上`?:` ———— `(?:……)`

**非捕获匹配**的若干个操作符：

> * 需要注意的是：虽然非匹配捕获不将匹配值暂存以便随后替换时调用，但匹配处依然是将来可替换的位置

在Python代码中使用正则表达式，匹配和捕获以及随后的替换，有更灵活的方式，因为可以对那些值直接编程。

以下为非获取匹配，也就是说，该匹配不需要获取供以后使用。预查不消耗字符，也就是说，在一个匹配发生之后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始

> * `(?=pattern)`：正向肯定预查（look ahead positive assert），在任何匹配规则的字符串开始处匹配查找字符串
> * `(?!pattern)`：正向否定预查（negative assert），在任何不匹配规则的字符串开始处匹配查找字符串
> * `(?<=pattern)`：反向（look behind）肯定预查，与正向肯定预查类似，只是方向相反
> * `(?<!pattern)`：反向否定预查，与正向否定预查类似，只是方向相反

### 控制标记

有几个全局控制标记（Flag）需要了解，其中最常默认指定的有 `G` 和 `M`：

`A`/`ASCII`，默认为 `False`

> * `\d`, `\D`, `\w`, `\W`, `\s`, `\S`, `\b`, 和 `\B` 等只限于 ASCII 字符
> * 行内写法：`(?a)`
> * Python re 模块中的常量：`re.A` `re.ASCII`

`I`/`IGNORECASE`，默认为 `False`

> * 忽略字母大小写
> * 行内写法：`(?i)`
> * Python re 模块中的常量：`re.I` `re.IGNORECASE`

`G`/`GLOBAL`，默认为 `True`

> * 找到第一个 match 之后不返回
> * 行内写法：`(?g)`
> * Python re 模块中这个标记不能更改，默认为 TRUE

`L`/`LOCALE`，默认为 `False`

> * 由本地语言设置决定 `\d`, `\D`, `\w`, `\W`, `\s`, `\S`, `\b`, 和 `\B` 等等的内容
> * 行内写法：`(?L)`
> * Python re 模块中的常量：`re.L` `re.LOCALE`

`M`/`MULTILINE`，默认为 `True`

> * 使用本标志后，`^` 和 `$` 匹配行首和行尾时，会增加换行符之前和之后的位置。
> * 行内写法：`(?m)`
> * Python re 模块中的常量：`re.M` `re.MULTILINE`

`S`/`DOTALL`，默认为 `False`

> * 使 `.` 完全匹配任何字符，包括换行；没有这个标志，`.` 匹配除了 `n` `r` 之外的任何字符。
> * 行内写法：`(?s)`
> * Python re 模块中的常量：`re.S` `re.DOTALL`

`X`/`VERBOSE`，默认为 `False`

> * 当该标志被指定时，Pattern 中的的空白符会被忽略，除非该空白符在圆括号或方括号中，或在反斜杠 `\` 之后。这样做的结果是允许将注释写入 Pattern，这些注释会被 Regex 解析引擎忽略。注释用 `#` 号来标识，不过该符号不能在字符串或反斜杠之后。
> * 行内写法：`(?x)`
> * Python re 模块中的常量：`re.X` `re.VERBOSE`

### 几个最常用的Regex

* matching username：`/^[a-z0-9_-]{3,16}$/`

* matching password：`/^[a-z0-9_-]{6,18}$/`

* matching a HEX value：`/^#?([a-f0-9]{6}|[a-f0-9]{3}$/`

* maching s slug：`/^[a-z0-9-]+$/`

* matching email address：`/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6}$/`

* matching a URL：`/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6}([\/\w \.-]*)*\/?$/`

* matching an IP address：`/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/`

* matching a HTML tag：`/^<([a-z+)([^<]+)*(?:>(.*)<\/\1$/`

## BNF 以及 EBNF

BNF - Backus-Naur Form（BNF，巴科斯-诺尔范式）
EBNF - Extended Backus-Naur Form（EBNF）

相关的基本符号：

> * `::=` 表示定义；
> * `<>`  尖括号内表示必选内容；
> * `[]`  方括号内表示可选项；
> * `""`  双引号里的内容表示字符；
> * `|`   竖线两边的是可选内容，相当于or；
> * `*`   表示零个或多个……
> * `+`   表示一个或多个……

### 拆解

所谓拆解 ———— 把那些很艰难的任务无限拆分 ———— 直至每个任务都很小，小到都可操作为止。

**横向拆解**：拆解的第一种方法是把某个任务`拆分成若干个小任务`，我们称之为横向拆解

比如那刚开始学编程的时候怎么办？你其实需要运用拆分的本领：

> * 先囫囵吞枣至少读一遍教程；
> * 给自己搭好测试的环境（或许在 Regex101.com 上，或许用一个编辑器，比如 VS Code）；
> * 先不管什么意思，找一些 Regex 自己试试；
> * 正式进入 “精度” 状态，每一小节每一小节地突破；
> * 搞定一小节之后，就把它与之前的小节再反复翻两三遍；
> * 把学习任务拆分成若干块，再重新逐个突破，比如，匹配，替换，在编辑器中使用，在 Python 代码中使用；
> * 把各种操作符与特殊字符拆分成若干个组，而后，熟悉到牢记（而不用将来反复回来查询）；
> ……

事实上，当你习惯这么做了之后，就会“发现”一切的自学任务，其实都不是“难”，不过是“复杂程度不一”而已。很多人最终自学失败，要么是不懂拆分任务，要么就仅仅是`怕麻烦`而已 ———— 还是那句话，人活着就挺麻烦的……

**纵向拆解**：（也可以称为“分层拆解”）这种在自学复杂的概念体系时特别有用

编程这个东西，之所以刚开始觉得难学，是因为其中涉及的概念除了之前我们强调的“过早引用”之外，还有个特征：

> 有的概念虽然并不同属一个层面，却常常纠缠在一起，没有明确的提示……

所以，要在自学的过程中，不停的想办法把它们从层面上区分开来 ———— 不能总是把它们混在一块儿“大锅烩”

**触类旁通**的技能：

对所有复盘的结果，无一例外，根源都是当初立项的时候，很多重要细节没有想清楚，甚至没想到要去搞清楚，就已经开始行动……于是，在成本不断积累的情况下，没完没了地处理各种“意外”，没完没了地重新制定目标，没完没了地拖延，没玩没了的“重新启动”……直至开始苟延残喘，最后不了了之。`拆解的不够，就容易导致想不清楚，想错，想歪……`

也许，有人可能会理直气壮的反问，“怎么可能一开始就把所有情况都想清楚么！” 唉，是呀，以前我也是这么想的……直到吃了很多亏，很多很多亏，很多很多很大很大的亏，才“发现”且不得不痛下决心去接受：`事先想不清楚的，就不要去做`。这是一种特殊、且重要、又极有价值的能力。

从“小而完整”的东西开始做（任何事）非常重要。“小”无所谓，“完整”才是关键。

## 刚需幻觉

### 感觉总是最大的坑

我的结论是：`绝大多数人的自学能力，基本上都是被“自己的感觉”耽误掉的`

即，原本每个人都有一定的自学能力，但最终，都被自己的感觉给干掉了，直至全然失去自学能力 ———— 虽然其后也经常学习，但其后一生从事的全都是学习这个行为里最初级的模式：“模仿”

为什么“模仿”是学习行为里最初级的模式呢？

首先，模仿必须依赖模仿对象，受自己的视野所限制。

其次，模仿只能处理表里如一的简单知识和技能；一但遇到哪些深层次的、表面上看不大出来的，模仿就无效了，即便是非要模仿、楞模仿，结果就只能是“东施效颦”

在《把时间当做朋友》中，我就反复强调一件事：

> 不要问学它有什么用，学就是了……

这原本是自学的最佳策略之一，也是自学的最根本策略。然而，听进去这句话的人不多，无论遇到什么自学机会都会不由自主地问：

> 我学它有什么用啊？

如果，得到的答案中，那“用处”对自己不是“刚需”，瞬间就失去了动力，瞬间就放弃了追求……直至某一天，突然“发现”那竟然是个刚需……于是，临时抱佛脚。人么，总是对追求的事情形影相随；又有谁会对曾经放弃的事情念念不忘呢？于是，下一次还是会再做“预算不足”的决定

最终失去“自学能力”的人，都是因为`对“刚需”的判断失误 ———— 这就是我说的“刚需幻觉”`

### 拆解刚需幻觉

“刚需”幻觉的根源在于：你不会的东西，对你来说感觉上就不是刚需。

然而，只要你花了一点力气，真的掌握了它，你会有“两个”发现：

> * 你根本离不开它
> * 它其实真没多难……

第二个“发现”总是让你无比庆幸，但第一个“发现”更为重要，因为但凡哪怕只有过一次这样的经历，你就可以永久摆脱“刚需幻觉”的诅咒。

所以，当面对一向新技能的时候，“觉得并非刚需”肯定是幻觉。因为一个技能到底是不是刚需，在掌握它之前是不知道的……

> * 只有真正掌握了那个技能之后，那个技能才会“变”成刚需

并且，

> * 一旦掌握了某项技能，它只能是刚需

我们的大脑有一种神奇的功能 ———— “无论如何都会用已有信息拼成一个完整图像的功能”。“无论如何”的意思是说，不管那已有信息是多么凌乱、有多么残缺、有多么无意义，人脑竟然还是可以拼出一个完整的“有意义”的图像

所以，在决定学任何东西的时候，最好不要去咨询身边的人 ———— 除非你确定对方是高手，最好是自学高手。否则，你遇到的永远是怀疑、打击、甚至嘲笑。最令人遗憾、最令人无奈的是，那些人其实也不是坏人，他们其实也不是故意，他们只是被自己的“刚需幻觉”误导了而已，他们（竟然）以为所有人都和他们一样……然后，若是你（居然）听信了他们的话，那就实在是太惨了

> **要学，想学，那就自顾自的去学吧，用不着征求别人的意见！**

### 优势策略

首先，基础策略是，要深刻理解这个现象及其解释：

> 对任何一项技能来说，**刚需是自学的结果**，而不是自学的原因

而后，也是更为重要的一个策略：

> **做一个自驱动的人**，而非被外部驱动的被动的人

最后一个很简单却很有效的策略是三个字：之前提到过的：

> **找活干**

**一切的技能都是刚学** ———— 虽然，这并不意味着你不需要选择。然而，至于学还是不学，其实从来都不是从“有没有用”来判断的，真正有意义的判断依据只有一条：

> 有没有时间

有时间就学呗！没时间就挤时间呗！学得不够好怎么办？花更多时间呗……

## 全面 ———— 自学的境界

之前提到过那些“貌似一出手就已然是高手”的人，也为此做过一番解释：

> 他们的特点就是善于**刻意练习**……

为了真正做到刻意练习，更重要的是需要不断地进行**刻意思考** ———— 刻意思考自己究竟应该在那些方面必须刻意练习？

之前说过，人和人非常不同，于是，需要刻意练习的地方也各不相同。

不过，倒是有一个方面，所有的自学者都必须刻意练习 ———— 这是谁都逃不过的地方：

> **全面**

那些“貌似一出手就已然是高手”的人就是在这一方面超越了绝大多数人 ———— 在每个层面上，他们都学习得更全面，练习得更全面，使用得更全面，在使用此技能去创造的时候，思考得也就自然更为全面。于是，就产生了“全面碾压”的效果。

把自学当作一门手艺，把所有的技能也都当做一门手艺，那就相对容易理解了：

> **全面**是掌握一门手艺的基本

为了全面，当然要靠时间。所以，关于“混与不混”，我们有了更深刻却又更朴素的认识：

> 所谓的不混时间，无非就是**刻意练习、追求全面**

也正是这个原因，几乎所有自学高手都懂这个道理：

> 绝对不能只靠一本书

有个特别有趣的现象，我觉得绝大多数人平日里都挺大手大脚的，都挺舍不得对自己过分苛刻的，但一到买书这件事上，绝大多数人真的很节俭，真的很苛刻 ———— 对待越严肃的知识越是如此。他们好像完全不知道自己正在疯狂的虐待自己……的大脑

“第一次突破”很重要

如果一个人有过一次只通过阅读书籍即获得一项新技能的体验，那么，他们内心深处（更准确的说法是大脑的底层操作系统）的那个成本计算方法就会发生改变，心里想的更可能是：

> * 这肯定是有用的，一旦学会，收益可不是几十块钱的书价或者几百块课价那么一点点……
> * 至于是否能学会，主要看我投入的时间精力预算有多少……

我身边有很多自学能力非常强的人，在他们眼里，书是成本最低的东西，比起最终的收益来讲更是不值一提

更为重要的是，**一本书绝对不够** ———— 无论是谁写的，无论哪个作者多么著名，影响力有多大……因为，书也好，教程也罢，这种东西就是有“篇幅限制”的。更为关键的是，每个作者都有不一样的视角、不一样的出发点和不一样的讲解方式、组织方法

当你搞明白一本书，后面再多读哪怕很多本的时间精力成本都是很低的，但每多读一本都会让你在这个话题中变得更为完整。

针对同一个话题读很多本书的最常见体验就是：

> * 恩，这个点很好玩，这个角度很有意思
> * 看看比比前面几个作者怎么论述的呢？
> * 恩，怎么我看过竟然没注意到呢？

这最后一条真的是很令人恼火却又享受的体验。它令你恼火，是因为你竟然错过；它令你享受，是因为虽然错过却竟然还有弥补的机会

总有一天你会明白的，一切的“学会”和“学好”之间的差异，无非是**全面程度**的差异

于是，翻译过来，“学好”竟然如此简单：

> **多读几本书，狠一点，多读很多本书**

到最后，这种习惯会慢慢延伸到生活中。甚至，到最后，你做东西的时候都会想着顺手多做几个版本。

提高所学知识技能的“全面程度”，有个最狠的方法 ———— 再次说出来不惊人，但实际效果惊到爆：

> **教是最好的学习方法**

## 自学者的社交

很多人有莫名其妙的误解，以为“自学”（self-teching）就一定是“自己独自学”（solo-teching），殊不知，自学也需要社交。也有另外一些人，因为`“专心”`到一定程度，觉得社交很累，所以开始抵触一切社交。这些都不是全面的看法

事实上，在任何领域，社交都是必须的，只不过很多人没有建立、打磨过自己的社交原则，所以才被各种无效社交所累。就算讨厌，讨厌的也不应该是社交，而是无效社交。

在自学的任何一个阶段，学、练、用、造，社交都可能存在。

哪怕是在最枯燥，看起来最不需要社交的“练”的阶段，社交也会起很大的作用 ———— 在自己累了的时候，看到有人还在练，看到很多人都在练，看到很多人其实也挺累的但还在练……这些都是让自己感觉没那么费劲的好方法

实际上，在最初“学”的阶段，社交也是极为重要的。由于有`镜像神经元`的存在，所以，无论学什么技能，都要找到用那种技能的人，这样我们的镜像神经元才更容易被激发，学习效果才会更好。若是能找到热爱哪项技能，乃至于使用哪项技能就很开心的人，那就更好了。激情这东西，是少数幸运儿才长期持有的东西，大多数人小时候挺多，过了十五六岁之后就开始有意无意磨灭了激情，且不自知。

之前提到

> 当我们看到另外一个人正在做什么的时候，镜像神经元会`尽力`给我们足够的刺激,让我们“体验”那个人的感受

这句话里有个词很重要：尽力。因为镜像神经元只能调用我们大脑里已有的信息去模拟对方的感受，所以，`它多也就是“尽力”，无法做到“确保正确”`。

所以，很多人误以为他们眼里的成功者靠的是“坚持”、靠的是“毅力”，这完全是自己的镜像神经元“尽力”的结果，是“调用自己过往经验去**感同身受**的结果”……事实上呢？那些“成功者”其实并不在意成功，因为到死之前，成长不应该也不可能结束，因为那是他们的生活方式，学习、进步、探索、迂回，甚至折腾、挫败和迷茫，都是他们生活中必不可少的内容，这是最初不自觉的选择，谈不上什么“坚持”，谈不上什么“毅力”……说实话，对他们来说，不折腾才真痛苦呢，不学习才需要坚持和毅力呢。

再进一步，这也是为什么要选择朋友的原因。人与人之间有很大的差异，最大的差异来自于性格养成，大多数人会沦为表现型人格，只有少数人才会在不断调整中保持、呵护、进一步培养“进取型”人格。他们自然而然地更为乐观，更有耐心，更有承受力，更有战斗力，更能生产更能体验学习的乐趣。与这样的人在一起，学习会更容易 ———— 只因为镜像神经元会更容易地被正确的激发。说清楚了，道理其实挺简单的。

进而，想要把一门手艺搞到真正“精湛”的地步，最有效的方法就是尽早进入“造”的阶段 ———— 所谓的“造”，就是不断创造的“造”

自学这门手艺，很简单，就是不断地学：

学上几个，自然就很精湛。而其它的用自学是门手艺习得的手艺，基本上都可以用“是否做出了像样的作品”作为检验自己的那门手艺是否达到了精湛的衡量指标。

在我看来，有好作品的人都很聪明，但还是那句话，那不是天分和智商，那分明是有效积累。我个人最看重的个人品质之一，就是**有没有像样的作品**

人群中只有少数人最终能拿出完整的作品 ———— 人与人之间的差异是如此之大，乃至于少数人有作品，更少数人有好的作品，只有极少数极少数人才可能作出传世的作品；而与此同时，绝大多数人一辈子都没有像样的作品，他们连一篇作文都写不明白。于是，与有像样作品的人打交道，总是非常值得。

并且，跟他们打交道也不费劲，都是思考非常通透的人，通常沟通能力极强。哪怕沟通起来貌似费劲的一小部分，事实上也不是难以沟通，那只不过是人家简单朴实而已。

另外一个很自然的现象是，如果一个人能做出像样的东西来，那么他身边聪明人密度无论如何都会比其他人高出很多

地球上有效社交密度最高的地方，是GitHub。在GitHub上找到自己感兴趣的项目，而后为那项目贡献一己之力，用自己的工作赢得社区的认同……这就是GitHub上的社交方式。

所以，无论学什么，都要想尽一切办法尽快做出自己的作品。做一个产品出来的过程中，会模块另外一项自学者不可或缺的能力和素质：

> **完整**

与之前提到的修养合起来，就构成了自学者的最基本素养：

> * 学就学得`全面`；
> * 做就做得`完整`；

无论多小的作品，都会让创作者感受到“单一技能的必然无效性” ———— 你试试就知道了。哪怕你想做个静态网站，你都会发现，仅仅学会HTML/css是不够的，因为部署到远端服务器上的时候，你无论如何都得学学Linux基本操作……而已然具备了自学者基本素养的你，自然会想办法“全面掌握”，而不是糊弄一下而已。

更为重要的是，一旦你开始创作作品，你更大的“发现”就是，你肯定需要很多“之前看起来并不想干的知识与技能”，而非“只靠专业就够了”……

所以，“做得完整”从来都不是容易的事情。从这个角度去理解，你就会明白那些高明的手艺人为什么总是做小东西 ———— 那是因为在追求完整的过程中，你必然会发现，越小越容易完整。这也是为什么庸人总是好高骛远，因为他们不顾完整，所以就可以妄图建造海市蜃楼

手艺人不怕做的事小。而且，“小”无所谓，“完整”才是关键。

给自己足够长的时间去学；在充足“预算”之下耐心地练；不断找活干，以用带练；然后，最重要的是，一定要尽快尝试着作出属于自己的完整作品，无论大小。

`只有这样，你才是个值得被交往的人`

## 这是自学者的黄金时代

有事先问Google就成了自学者的必备修养

> 能Google出答案的问题，就不需要去麻烦别人

这也是一个自学者的基本素质

不认真使用Google，你就错过了整个人类历史上自学者的黄金时代

## 避免注意力飘逸

更多的时候我们不是“注意力不集中”，而是……更令人恼火的一个现象：

> “注意力所集中的焦点总是不断被自己偷偷换掉……”

说这种现象“令人恼火”，是因为那注意力所集中的焦点，是被自己偷偷换掉的！好奇心越重的人越是容易被注意力飘逸所累

好奇心是好东西，而且是必须认真呵护的东西 ———— 几乎是最重要、最强劲饿自学动力都混合着好奇心出现并持续。

然而，就是这个如此金贵的东西，也会成为拖累；而且若是真的被它拖累，那么最终真的会感觉非常遗憾，被好东西拖累 ———— 太可惜了

到今天为止，我自己依然还是个需要不断与注意力斗争的人 ———— 许多年前，我注意到这个现象的时候，经过思考就接受了一个事实：

> * 注意力漂移不是能杜绝的现象，但必须在关键时刻有所应对

在罗列并比较众多策略之后，我选了一个看起来最不相干，却最本质的策略：

> **把“全面完整”放到最高优先级**

我的操作方法是，在笔记本里罗列整理那些为了做到“全面完整”而必须优先做的事。除了上面罗列的这些东西外，在当前时间段，别的都不如它们重要

一旦发现自己的注意力没有集中在这上面的关键之时，一旦发现自己的注意力已经漂移到其他当前并不重要的事项上，就马上纠正

谁都知道应该先做**重要且紧急**的事情，可问题在于，如何判断“是否重要”呢？**全面完整**这四个字就会给我指引

## 如何成为优秀沟通者

沟通能力好与不好最核心的理由，应该是一个人最基本的选择而已：

> 看一个人是否重视沟通能力

非常遗憾，绝大多数人对沟通能力的重视远远不够 ———— 他们也不是不重视，就是重视的程度实际上太差了。别说双向沟通了，即便是单项沟通，向别人问个问题这么“简单”的事，其实也需要“学”与“练”

对沟通能力进行“刻意练习”的最佳方式是什么呢？其实还是你已经知道的：

> **教是最好的学习方法**

讲课、写教程、甚至写书 ———— 这是最高效的提升沟通能力的刻意练习手段

演讲能力、协作能力，其实同样也是手艺而已，但它们确实是很必要的手艺。尤其是，具备这两项手艺的人，在现在这样的社会里收入一定不差，不信你就观察一下身边的世界、你的眼界可以触达的人群

当然，绝大多数连一门手艺都没有弄明白的初学者，阅读以下内容时，会觉得“与当前的自己没关系”……不过，请注意，这绝对是“刚需幻觉”，千万不要被它悟误导

已经说了无数遍了：绝大多数手艺都是这样的：

> 原理很简单，精湛与否取决于重复的次数

以下，让我们从入门开始讲起，而后步入进阶，最后达到高级……

### 入门

> 内容第一

无论是平日里讲话、还是台上讲课，抑或是写篇文章、写本书，永远都是内容第一，至于形式，并非不重要，但绝对不能喧宾夺主。

通常，我们用“干货”来描述内容的重要性。第一步就是准备干货，至于修辞啊、笑点啊、炫酷幻灯片啊等等，都必须是次要的，否则就是喧宾夺主。`干货不够好，其他的做得越多、越好，最终越是容易露怯 ———— 这很可怕。`

所以，在你还没确定自己值得讲，别人值得听的内容的情况下，就去学习如何制作幻灯片，在我看来完全是浪费时间。

使用工具的技巧之一，就是用最朴素的方法使用最好的工具，这样成本最低效果最好。所以，我在讲课、演讲的时候，通常就只用最简单的模板，空白、单色背景那种，而后一页里只写一句话……这样的幻灯片，我只需要几分钟就能完成。而后，我的所有时间精力都放在精心准备内容上去了。高效、低成本。

**做事不分轻重，这不对**。

> **内容质量**

内容第一，就决定了另外一个事实：

> * 不要讲或写你并不擅长的事

换句话说，不要分享你做的不够好、做得不够精湛的手艺。讲课也好、写书也罢，都是分享。分享的意思是说，你有别人想要的东西 ———— 别人想要的，就是他们学不好、做不好的东西……若是你自己手艺不强手艺不精，其实就没什么可分享的，就算你想“分享”别人也不要

你值得讲，别人值得听的，一定是你做的比别人更好的东西，就这么简单

所以，在自己磨炼手艺的时候，可以同时磨炼沟通能力；然而，一旦需要将讲，需要写，那么就说明，你自己确信自己做的比别人更好、比别人更精，所以，你值得讲，所以，人家值得听。

`一旦你确定自己有值得讲、人家值得听的东西，那么，内容质量的第一要素已经完成了`，接下来要注意那些呢？只需要关注质量的三个方面就可以了。

> * 重点突出
> * 例证生动
> * 消除歧义

“重点突出”：是最简单朴素、成本最低的“优秀结构”。既然是沟通，就要了解对方。在绝大多数情况下，`对方想要的才是重点`。

“例证生动”：寻找好例子是需要很多时间精力的事情 ———— 从来没有任何“信手拈来”的例子。信手拈来是读者或者听众的感觉而已，对你来说，肯定是举重若轻的。

“消除歧义”：这是真功夫，因为这东西很难把自己关在屋子里自顾自练成。并且，每个人有自己的“容易引发误解”的特殊属性，大家各不相同 ———— 于是，只能靠自己探索

无论如何都不能骂听众或者读者傻逼，他们所有看起来傻逼的反映，都是你所说、你所写引发的 ———— 这是百分之百清楚无误的事实。当年我写博客的时候，绝不删除任何留言。其中最大的理由就是，无论那留言显得多么荒谬，甚至干脆是谩骂，都值得我们认真思考：

> 我到底说什么了？居然引来这种反应？

看多了，思考多了，你就有自己的策略了。

> **内容组织**

只有一个重点的时候，其实并不需要组织；但若是有一个以上的重点，那么这些重点之间会产生逻辑关系:

> * 并列
> * 递进
> * 转折

其中最有效的组织方式，竟然是最简单的，并且只有一个：**层层递进**。并且，另外一个建议是：`3`是重点数量的极限，如果有多个重点怎么办？那就把它分到不同的分组里

另外一个策略，是与“递进”的逻辑关系组合使用的 ———— 你要区分针对你所谓的重点，对方的已知状态。大家都知道的，何必当做重点？于是，未知程度高的，放到不那么高的后面

### 进阶

当入门的手段已经熟练了，就可以做很多所谓“锦上添花”的事情。锦上添花据说有很多种手段，比如，制造笑点啊，使用炫酷的幻灯片啊等等……但我只想给你讲一个学会了就够用，却也是最简单、最直接，然而又是最有效的手段：

> **输送价值观**

而所谓价值观，定义很简单：

> 你的价值观，就是你认为什么比什么**更重要**

最初的时候，有个很难以跨越的障碍：

> 感觉总是需要为自己塑造权威感 ———— 否则就害怕没人听、没人看、没人信……

这是很多人掉进去的坑。刚开始的时候，自己就不是权威啊，无论怎么装神弄鬼，事实上就不是么！

很多人没想明白，因为害怕没人听、害怕没人看、害怕没人信，所以就开始各种作弊，包括各种装神弄鬼，各种欺世盗名……这么做，暂时管用，长期来看，肯定是吃亏的

因为作弊其实并不难，装神弄鬼其实并不难，欺世盗名其实并不难 ———— 真正难得是长期作弊……长期欺骗有多难呢？难到根本不可能的地步。所以别骗人，因为早晚会露馅……

花那么长时间作弊什么的，不如花那么长时间磨练手艺，你想想看是不是这个道理？

于是，千万别扭曲了自己，是什么样就是什么样，该怎么做就怎么做。而另外一个事是确定的：

> 分享多了，就自然进步了……

在求知的领域里，分享的越多，进步越快，且社交有效性提高得更多

### 高级

无论是什么手艺，大多数人都可以入门、少数人可以进阶……再往后，通常就被认为是个人“造化”了。

可这所谓的“造化”究竟指的是什么呢？

我觉得通过这本书，我可以向绝大多数普通人解释这个“玄学词汇”了……

> 这里所谓的"造化",指的应该是一个人`“融会贯通能力”` ———— 有“造化”的人，不过是把大量其他领域里的技能、技巧、甚至手艺学来而后应用到自己的手艺之中……

有这种能力的人，普遍有两个能力：

> * 他们自学很多看起来不相干的能力
> * 他们对自己的手艺充满尊重和热爱

这其中的第二个特征，很可能是第一个特征的根源，因为他们对自己的手艺充满了尊重与热爱，所以，他们追求全面，他们刻意练习，他们还刻意思考……由此引发了对一些和自己手艺相关的东西都感兴趣 ———— 虽然在外界看来那两样东西可能全无联系

在计算机领域里有个著名的词汇诞生：全栈工程师。其实所有精湛的手艺人，都明白且认同这个道理：

> 学无止境

于是，最后一个重要技巧,不仅仅是“不断磨练当前的手艺”，还有就是**不断向所有的手艺人学习**。再进一步，技巧没用了……想再进一步，靠的是另外一个层次的东西 ———— 那就是`尊重与热爱`

**Love is the power**，没有什么比尊重与热爱更高级的了

## 自学者的终点

……磨练自学手艺的你，早晚会遇到这种情况：

> 必须学会一个没人教、没人带，甚至没有书可以参考的技能

这么多年来，我能够“学会一些没人教、没人带，甚至没有书可参考的技能”，更多的时候仰仗的是一个我已经告诉过你的“秘密”：

> 刻意思考：这东西我还能用在哪儿呢？

再进一步，当我们在最开始的时候说，“尽量只靠阅读习得一项新技能”的时候，有一个重点现在终于在之前的很多解释与讲解之后能说清楚了：

> 我们并不是不要老师这个角色了，准确的讲，我们只不过是不再需要“传统意义上的老师”了而已

首先，我们把自己当做老师，很多时候想在身边找到好老师是很难的，甚至是不可能的。在这种情况下，我们没有别的选择，我们只能把自己当做老师去教自己

其次，就算我们100%只依靠阅读，那内容不还是别人写的吗？写那内容的人，实际上就是老师。而阅读的好处在于，对老师的要求中没有地理位置的限制。反正，写书的人群中，牛人比例相对较高，这是事实 ———— 古今中外都一样

进而，更为重要的是，一旦你把整个互联网当做一本大“书”，把Google当做入口，实际发生的效果是：

> 你把老师这个角色“去中心化”了……

这样，你学不同的东西就可以找不同的老师；即便是相同的东西，你也可以找很多老师；对于任何一个老师，你都可以“弱水三千只取一瓢”也就是说，挑他最厉害的部分去学……不就是多买几本书吗？不就是多搜索几次，多读一些文档吗？

最后你竟然还有最厉害的一个**小招数**：

> 无论学会什么，都要进一步**刻意思考**：这东西我还能用在哪儿呢？

于是，你“一下子”就升级了 ———— 用这样的方式，相对于别人，你最可能“学会几乎任何一个没人教、没人带、甚至没有书可参考的技能”……

### 我们终于可以好好总结一下：

> * 你一定要想办法启动自学，否则你没有未来；
> * 你把自己当做一门手艺，长期反复磨炼它；
> * 你懂得学、练、用、造各个阶段之间的不同，以及针对每个阶段的对应策略；
> * 面对“过早引用”过多的世界，你有你的应对方式；
> * 你会“囫囵吞枣”，你会“重复重复再重复”，你深刻理解“读书百遍其义自见”；
> * 以后你最擅长的技能之一就是拆解拆解再拆解；
> * 你用你的拆解手艺把所有遇到的难点都拆解成能搞定的小任务；
> * 自学任何一门手艺之前你都不会去问“有什么用”，而是清楚的知道，无论是什么只要学会了，就只能也必然天天去用；
> * 你没有刚需幻觉，你也没有时间幻觉，你更没有困难幻觉，反正你就是跟清醒；
> * 不管你新学什么手艺，你都知道只要假以时日你就肯定能做好，因为所有的手艺精湛，靠的只不过是充足的预算；
> * 你知道如何不浪费生命，因为只要不是在刻意练习、不是在刻意思考，那就是在“混时间”；
> * 你总是在琢磨，你能做个什么新作品；
> * 你刻意地使用你的作品作为有效社交的工具，也用作品去过滤无效社交；
> * 你乐于分享，乐于阅读也更乐于协作 ———— `因为这世界怎么帮助你的，你就想着要怎样回报`；
> * 你把全面和完整当做最高衡量吧标准，也用这个标准去克制、应对自己的注意力漂移；
> * 你会不断自学新的手艺，因为你越来越理解单一技能的脆弱，越来越理解多项技能的综合威力；
> * 你越来越依赖互联网，因为它是你最喜欢的“书”，而Google是你最好的朋友 ———— 他总是能帮你找到最好的老师；
> * 偶尔你会学会没人教、没人带、甚至没书可参考的手艺，别人都说你“悟性”高，可你自己清楚的知道那其实是怎么回事；
> * 你越来越明白，其实没什么“秘密”，越简单、越朴素的道理越值得重视；
> * 你发现你用来思考的时间越来越多 ———— 准确的讲，是“琢磨”……只不过是你真会琢磨了 ———— 你很清楚你应该花时间琢磨的是什么

自学不过是一门手艺，而且还是谁都能掌握的。不要“试试”而已，而是“直接开干” ———— 这样才好

最后还有个需要补充的是：很多人崇尚“刻苦”，并且刻意强调其中的“苦” ———— 古训中所谓的“吃得苦中苦，方为人上人” ———— 这一点我并不认同，并且还是深刻的不认同

我的观察是，所谓的“苦”，是哪些根本不会自学的人对自学者的所作所为的错误理解。

自学一点都不苦，道理也很简单：

> 因为自学者是自发去学的，原动力在于自己

由于原动力在于自己，遇到困难时，当然同样苦恼；可不一样的是，有持续的原动力去克服那些困难，于是，总是在不断克服困难之后获得更大的愉悦、更大的满足。


