# 从开篇到part1的部分

> **程序**

按照一定顺序完成任务的流程

> **清楚的说明1%**

*根据 2017 年的统计数据，从 1977 年到 2017 年，40 年间全国大学录取人数总计为 1.15 亿左右（11518.2 万），占全国人口数量的 10% 不到，另外，这其中一半以上是专科生…… 你觉得那些 4% 左右的本科毕业生中，带着自学能力走入社会的比例是多少？不夸张地讲，我觉得 1% 都是很高的比例了*

我理解以上的话，它是像实世界一个抽象的归类一样，取用了大概率的事件，只要足够说明问题就好了

> **如何解决焦虑 / 贩卖焦虑**

*经常有一些人指责另外一些人 “贩卖焦虑” —— 根据我的观察，这种指责的肤浅在于，焦虑不是被卖方贩卖的产品，焦虑其实是买方长期自行积累的结果。别人无法贩卖给你焦虑，是你自己焦虑 —— 是你自己在为自己不断积累越来越多的焦虑*

其实焦虑，就和肥胖一样。当你有一段时间没有锻炼的时候你会长肉，我曾今常常因为这件事情烦恼。后来想明白了，这个无非是过往的积累，接受现状然后努力向前就好。毕竟健身、学习都是一辈子的事情。而且我发现其实你用多长时间积累的肥肉常常需要用相同的时间减掉，其实有时候还会快一些（当然我真的没试过几个月瘦身的事情，针对这事情先不做评论）

> **自学能力**

*哪怕有很强的自学能力的意思也并不是说，什么都能马上学会、什么都能马上学好，到最后无所不精无所不通…… 因为这里有个时间问题。无论学什么，都需要耗费时间和精力，与此同时更难的事情在于不断填补耐心以防它过早耗尽*

自学能力 ！= 马上学会/马上学好 
这是需要耗费时间和精力并且需要不断填补耐心以防它过早耗尽

> **工具**

*虽然写代码这事儿刚开始学起来好像门槛很高，那只不过是幻觉，其实门槛比它更高的多的去了。到最后，它就是个最基础的工具，还是得靠思考能力 —— 这就好像识字其实挺难的 —— 小学初中高中加起来十来年，我们才掌握了基本的阅读能力；可最终，即便是本科毕业、研究生毕业，真的能写出一手好文章的人还是少之又少一样 —— 因为用文字值得写出来的是思想，用代码值得写出来的是创造，或者起码是有意义的问题的有效解决方案。有思想，能解决问题，是另外一门手艺 —— 需要终生精进的手艺。*

思想才是真正需要精进的手艺，需要不断的打磨自己的思维方式和思维模型，之前别人说你的PPT做的很好，但是很多人都会停留在美工上面。很想解释，这个不仅仅是美工的问题，但一直找不到一个合适的话术。我觉得这个启发了我，PPT也是一个工具，一个表达你思维的工具，核心还是要有思想。思想才是核心








# 例子：Python

---

> **高级语言的基本构成**

*所有的编程语言基础都一样，所有的编程语言都是我们指挥计算机的工具。无论怎样，反正都需要**输入输出**，无论什么语言，不可能没有**布尔运算**，不可能没有**流程控制**，不可能没有**函数**，只要是高级语言，就都需要编译器…… 所以，掌握这些基本概念，是将来持续学习的基础。*

## 值及其相应的运算

> **字符串操作符与列表操作符**

字符串操作符有三种操作：
* 拼接：`+` 和 `' '`
* 拷贝：`*`
* 逻辑运算：`in`、`not in` 以及 `<`、`<=`、`>`、`>=`、`!=`、`==`

_字符之间之所以可以被逻辑运算符运算，这是因为字符对应着`Unicode`码，字符在被比较的时候，被比较的是对应的`Unicade`码。当字符串比较的时候，将从两个字符串各自的第一个字符开始逐个比较，`一但决出胜负马上停止`_

_因为列表和字符串一样，都是`有序容器`（容器还有另外一种是无序容器），所以，它们可用的操作符其实相同。两个列表在比较时（前提是两个列表中的数据元素类型相同），遵循的还是跟字符串比较相同的规则：“一旦决出胜负马上停止”。但，实际上，由于列表中可以包含不同类型的元素，所以，通常情况下没有实际需求对他们进行 “大于、小于” 的比较。（比较时，类型不同会引发 `TypeError`……）_

> **关于布尔值的补充**

`True or 'Python' 将返回 _True_ `
这就需要对False的定义有一个理解 - Here are most of the built-in objects considered False:
* constants defined to be false: None and False.
* zero of any numeric type: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)
* empty sequences and collections: '', (), [], {}, set(), range(0)
所以'Python'是个非空的字符串，即，不属于是`empty sequences`，所以它不被认为是`False`，即，它的布尔值是`True`
所以**每个变量或者常量，除了它们的值之外，同时还相当于有一个对应的布尔值**

> **总结**

数据类型，本质上是`值`的类型。所有的`值`都有两种操作方式，即*操作符*和*函数*，而所有的*操作符*和*函数*最终都会返回一个对应的`值`，及其相应的布尔值
所以，**所谓的编程的知识结构，无非是 *值的数据类型及其运算* 而已**

另，关于BFN（有关优先级的前置了解内容）：https://en.wikipedia.org/wiki/Backus-Naur_form

## 流程控制

控制流介绍：https://en.wikipedia.org/wiki/Control_flow

> **两种循环结构**
* Collection-controlled loops（以集合为基础的循环）———— for循环
* Condition-controlled loops（以条件为基础的循环） ———— while循环

> **For……in……else**

For 语句块还可以附加一个 else —— 这是 Python 的一个比较有个性的地方。附加在 for 结尾的 else 语句块，在没有 break 发生的情况下会运行

>**pass**

pass语句什么都不干，换个角度去理解的话可能更清楚 ——— pass 这个语句更多是给写程序的人用的。当你写程序的时候，你可以用 pass 占位，而后先写别的部分，过后再回来补充本来应该写在 pass 所在位置的那一段代码

## 函数

>**print()**

print(*object, sep=' ', end='\n', file=sys.stdout, flush=False)
* print()这个函数是可以往文件里写数据的，只要指定 file 这个参数为一个已经打开的文件对象就可以了
* 其中sep、end、file、flush都是Keyword Arguments，而其它的是 Positional Arguments

>**可选位置参数 - 参数中的[]**

_exec(object[,globals[,locals]])_

这些方括号的意思是说：
* 没在方括号里的 object 是不可或缺的函数，调用时必须提供；
* 可以有第二个参数，第二个参数会被接收为 globals；
* 在有第二个参数的情况下，第三个参数会被接收为 locals；
* 但是，你没办法在不指定 globals 这个位置参数的情况下指定 locals……

>**可接收多个值的位置参数**

print(*object, sep=' ', end='\n', file=sys.stdout, flush=False)
* *objec……表示这个位置可以传入多个参数，有这种参数时要求函数要么只有一个位置参数，要么此类参数只能在最后

## 字符串

> 字符串的转换：一个字符串由 0 个字符或者多个字符构成，它最终也要被转换成数值，再进一步被转换成二进制数值。空字符串的值是 None，即便是这个 None —— 也最终还是要被转换成二进制的 0

> 切片：s[strar:stop:step] ———— 返回从索引值start开始一直到索引值为stop那个字符之前的，以step为步长提取的所有字符

> int()接收字符串参数是，只能做整数转换
_例如：int('3') - 正确 ；int('3.14') - 错误_

> **str类方法：**
* 大小写转换
str.upper() - 全部变为大写
str.lower() - 全部变为小写
str.swapcase() - 逐个字符更替`大小`写(小写则改为大写，大写则改为小写)
str.casefold() - 全部变为小写(相对于lower，可以处理更多欧洲语言的字符)
str.capitalize() - 行首字母转换为大写
str.title() - 词首字母转换为大写

* 搜索、替换、删除、拆分、拼接、格式化

---
搜索
str.count(sub [,start=0[, end=len(str)-1]])，返回sub在str中出现的次数
str.find(sub[, start[, end]])，返回sub在str中第一次出现的位置，没有则返回-1
str.rfind(sub[, start[, end]])，返回sub在str中最后一次出现的位置，没有则返回-1
str.index(sub[, start[, end]])，返回sub在str中第一次出现的位置，`没有则引发ValueError`
tr.rindex(sub[, start[, end]]),返回sub在str中最后一次出现的位置，`没有则引发ValueError`

str.start`s`with(prefix[, start[, end]]),判断str是否以prefix开始，返回布尔的判定结果
str.end`s`with(suffix[, start[, end]])，判断str是否以prefix结束，返回布尔的判定结果

---
替换
str.replace(old, new[, count])，将一定次数的old替换为new
str.expandtabs(tabsize=8)，将字符串中的TAB替换为空格，默认是8个空格

---
删除
str.strip([chars])，去除字符串首尾的字符串，如果为空则会去除一个字符串首尾的所有空白，包括空格、TAB、换行符等等
str.lstrip() / str.rstrip() - 只做左边/右边的处理

---
拆分
str.splitlines() - 返回list结构，由被拆分的每一行作为其中的元素
str.split(sep=None, maxsplit=-1) - 将字符串根据分隔符拆分一定的次数，-1为全部拆分，none代表各种空白
str.partition()

---
拼接
str.join(_iterable_)，将str拼入iterable

* 排版

str.center(width[, fillchar]) - 居中对齐，需要设置整行的长度，fillchar只接收单个字符，用于填充空白
str.ljust(width[, fillchar]) - 左对齐，其他同上
str.rjust(width[, fillchar]) - 右对齐，其他同上
str.zfill() - 将字符串转换成左侧由 0 填充的指定长度字符串

* 格式化：所谓格式化，是将特定变量插入特定位置的过程

str.format(*args, **kwargs) - 在一个字符串中，插入一个或多个占位符 —— 用 {} 括起来，而后将str.format()相应的参数，依次插入占位符中

f-string，用法与str.format()相同，写法更简洁一点：f'{name} is {age} years old' == '{} is {} years old'.format(name,age)

> 字符串属性：

![](images/Container in python.png)