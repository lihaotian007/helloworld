# Prat 2

## 笨拙与耐心

### 自学的过程

自学的过程，实际上需要拆解为以下四个阶段，虽然他们之间常常有部分重叠：`学、练、用、造`。学就需要重复，甚至很多次重复，尤其是在面对充满了“过早引用”现象的知识结构的时候

### 关于耐心

自学是一门手艺，编程很大程度上也是一门手艺，掌握它在绝大多数情况下与天分智商全无关系。所有手艺，最基本的特征就是：`主要靠时间`

一切“主要靠时间”的活动都一样，都需要在从事之前认真做“心理建设”。通常情况下，读一本教程，上个学习班，就“会”了 ———— 几乎很定是错觉甚至是幻觉

* 首先要明白，这肯定是比“天真的想象”要长的多的过程。
* 其次要明白，并且要越来越自然地明白，哪儿哪儿都需要很多重复。读，要读很多遍；练，要练很多遍；做，要做很多遍……

有了这样的心里建设，就相对更容易保持耐心

人们缺乏耐心的常见根源就是`“之前根本没准备花那么多时间和精力”`，所以当然很容易超出“时间和精力的预算”，当然相对更容易焦虑 ———— 就像没有多少本钱的人做生意常常更容易失败一样

预算观念非常重要 ———— 这个观念存在与否，成熟与否，基本上决定一个人未来的盈利能力

大多数人对此不仅不成熟，甚至干脆没有预算观念！———— 这也是为什么绝大多数人不适合创业的最根本原因。不夸张地讲，未来的你只需要恪守一个原则，就很可能会因此超越99%的人：

* 绝对不做预算不够的事情

### 人生很长，何必惊慌

有一个现象，不自学的人不知道

真正开始自学且不断自学之后，刚开始总是觉得时间不够用 ———— 因为当时的自己和其他人没什么太大区别

随着时间的推移，不仅差异会出现，自我认知差异也开始越来越明显：

* 别人的时间都白过了，自己的时间都有产出……

到了下一个阶段，在其他人不断焦虑的情况下，自己却开始越来越淡定：

* 因为早已习惯了投入大量时间换取新技能……

等后来真的开始用这些技能做事，不断地做其他人因为时间白过了或者因为投入的“预算”不够而学不会做不到的事情 ———— 并且还能充分明白，这并不是自己聪明、有天分的结果；只不过是做了该做的事情，投入了该投入的“成本”和“预算”而已……

于是，就真的能理解下面这句话背后的深意：

> 人生很长，何必惊慌

反正这事和天分与智商基本没有任何关系

## 刻意练习

手艺这个东西，尤其需要刻意练习。我们说，手艺么，主要是靠时间……这里的“时间”，准确的讲，就是“刻意练习”的时间，而不是任何时间

许多年前，资质平庸的我，一直苦恼一件事：

* 为什么自己无论干什么都笨手笨脚、羞这儿羞那儿的……
* 为什么与此同时，总是能看到另外一些人，给人感觉“一出手就是高手”呢？

后来我才“羞耻”的反映过来：

* 我花在刻意练习上的时间太少了；
* 并且，也没有刻意思考那些地方我应该去刻意练习

就是这一点的差别造成了那么大的差距

所谓的“混”，解释很简单：

> 不做刻意练习的人就是在混时间

### 刻意练习的应对策略

于是，你可能感受到了，其实吧，所谓“刻意练习”，其实是`“刻意思考哪里需要刻意练习”`之后最自然不过的事情 ———— 所以，“刻意思考”才是关键。

应对策略很简单：

* 准备个专门的地方做记录

人们常说：凡事，就怕琢磨……

那些高手，无一例外都是善于琢磨的人……可是，他们在琢磨什么呢？为什么他们会琢磨这些事呢？其实有时候差距只在一线之间

## 为什么从函数开始

正常情况下，输入多于输出，或者，输入远多于输出，不仅是自然现象，也是无法改变的规则。

`从小入手，从来都是自学的好方法。`我们没有想着一上来就写程序，而是写“子程序”、“小程序”、“短程序”。从结构化编程的角度来看，写函数的一个基本要求就是：

* 完成一个功能；
* 只完成一个功能；
* 没有任何错误的只完成一个功能……

函数涉及的内容：

> 参数的传递
> 多参数的传递
> 匿名函数以及函数的别称
> 递归函数
> 函数文档
> 模块
> 测试驱动程序
> 可执行程序

你要习惯，归纳、总结、整理的工作，从来都不是一次就能完成的，都需要反复多次之后才能彻底完成。必须习惯这种流程 ———— 而不是像那些从未自学过的人一样，对这种东西想当然地全不了解

结构化编程的核心就是拆分任务，把任务拆分到不能再拆分为止 ———— 什么时候不能再拆分了呢？就是当一个函数完成一个功能的时候……

如何函数内部并未定义返回值，那么，该函数的返回值是None，当None被当做布尔值对待的时候，相当于是False。这样的设定，使得函数调用总是可以在条件语句中被当做判断依据

## 参数

### 关于全局变量和局域变量

每次某个函数被调用的时候，这个函数会开辟一个新的区域，这个函数内部所有的变量，都是局域变量。更为重要的是，当外部调用一个函数的时候，传递的不是变量，而是那个变量的值

* 在函数内部被赋值而后使用的，都是局部变量，它们的作用域是局部，无法被函数外的代码调用
* 在函数外被赋值而后开始使用的，是全局变量，它们的作用域是全局，在函数的内外都可以被调用

有一种情况需要格外注意 ———— 在函数内部处理被传递进来的值是可变容器（如：列表）的时候。在函数内部对可变容器的改变会影响原可变容器。所以，`一个比较好的习惯是，如果传递进来的值是列表，那么在函数内部对其操作之前，先创建一个对它的拷贝`

定义如此，但通常程序员们会严格遵守一条原则：

> 在函数内部绝对不调用全局变量。即便是必须改变全局变量，也只能通过函数的返回值在函数外改变全局变量

你也必须遵守同样的原则。而这个原则同样可以在日常的工作生活中“调用”：

> 做事的原则：自己的事自己做，别人的事，最多通过自己的产出让他们自己去搞……

### Arbitrary Positional Arguments / Arbitrary Keyword Arguments

对于`Arbitrary Positional Arguments`函数内部就是把接收到的参数当作容器处理的，于是，在调用这个函数的时候，向它传递任何容器都会被同样处理。

* example：
* say_hi(*'Python') -> ['p','y','t','h','o','n'];
* say_hi('Python')  -> 'Python'

在定义可以接收一系列值的位置参数时，建议在函数内部为该变量命名时总是用复数。同时一个函数中，可以接收一些列值的位置参数只能有一个，并且若是还有其他位置参数存在，那就必须把这个可以接收一系列值的位置参数排在所有其他位置参数之后

对于`Arbitrary Keyword Arguments`,在接收时用的是对字典的迭代方式，那么在调用函数的时候也可以直接使用字典的方式。至于在函数内部用怎样的方式处理这个字典，是自己的选择

### 参数的位置

* positional
* Arbitrary Positional
* Keyword
* Arbitrary Positional

## 化名

更多的时候，为函数取一个化名，应该是为了提高代码可读性 ———— 对自己或其他人都很重要

## lambda

### 匿名函数的用法

写一个很短的函数可以用`lambda`关键字

> lambda_expr ::= "lambda" [parameter_list] ":" expression

先写`lambda`这个关键字，其后分为两个部分,`:`之前是参数，之后是表达式。**表达式的值就是这个函数的返回值**

> **`：`之后有且只能有`一个`表达式。这个函数没有名字，所以是`匿名函数`

### 匿名函数的使用场景

* 做为另一个函数的返回值

---

def make_incrementor(n):
    return lambda x: x + n

f = make_incrementor(42)
f(0)

f是什么呢？它是`<function __main__.make_incrementor.<locals>.<lambda>(x)>`

> `f = make_incrementor(42)` 是将 `make_incrementor(42)` 的返回值保存到 `f` 这个变量之中；
> 而 `make_incrementor()` 这个函数收到42这个参数之后，返回一个函数 `lambda x: x + n`
> 于是，f保存的函数是 `lambda x: x + n`
> 所以，`f(0)` 是向这个匿名函数传递了一个 `0`

---

* 作为某函数的参数

> 没有理解 `lambda functions can reference variables from the containing scope`

## 递归函数

递归函数（Recursive Functions）———— 那些在自身内部调用自身的函数。一个递归函数之所以是一个有用、有效的递归函数，是因为它遵守了递归三原则：

* 根据定义，递归函数必须在内部调用自己
* 必须设定一个退出条件
* 递归过程中必须能够`逐步达到`退出条件

> 利用布尔值的特性表示1/10的概率：`not random.randrange(0,10)`

## 函数的文档

### Docstring

在函数定义内部，我们可以加上Docstring；将来函数的“用户”就可以通过`help()`这个内建函数，或者`._doc_`这个Method去查看这个Docstring，即，该函数的“产品说明书”。

> Docstring如若存在，必须在函数定义的内部语句块的开头，也必须与其他语句一样保持相应的缩进。Docstring放到其他地方不起作用

### 书写Docstring的规范：

* 无论是单行还是多行Docstring，一概使用三个双引号扩起
* 在Docstring内部，无论文字开始之前，以及文字结束之后，都不要有空行
* 多行DoCstring，第一行是概要，随后空一行，再写其他部分
* 完善的Docstring，应该概括清楚以下内容：参数、返回值、可能触发的错误类型、可能的副作用、以及函数的使用限制等等
* 每个参数的说明都是用单独的一行

需要格外注意的是：

> Docstring是写给人看的，所以在复杂代码的 Docstring 中，写`Why`远比写What更重要（你先记住这一点，以后的体会自然会不断加深）

## 保存到文件的函数

这样可以被外部调用的 `.py` 文件，有个专门的称呼，模块（Module）———— 于是，其实任何一个 `.py` 文件都可以被称为模块。系统通过`import……`去寻找

### 模块文件系统目录：

目录检索顺序：

* 先去看看内建模块里有没有你所指定的名称；
* 如果没有，那么就按照`sys.path`所返回的目录列表**顺序**去找（sys返回的目录列表里，你当前的工作内容排第一位。可以用append()添加搜索位置

> 如果当前目录中并没有`mycode.py`这个文件，那么，`mycode`会被当做目录名再被尝试一次 ———— 如果当前目录内，有个叫做`mycode`的目录且该目录下要存在一个`_init_.py`文件，它们处在一个独立的 **命名空间**。那么`from mycode import *`的作用就是把`mycode`这个文件夹中的所有`.py`文件全部导入……

### 模块中的非函数

一个模块文件中，不一定只包含函数，它也可以包含函数之外的可执行代码。**只不过在`import`语句执行的时候，模块中的非函数部分的可执行代码，只执行一次**

### dir()函数

这个模块的用户，可以用dir()函数查看模块中可触达的变量名称和函数名称

## 测试驱动的开发

“算法”其实没多神秘，就是“解决问题的步骤”而已

测试驱动开发：“通过先想办法验证结果而后从结果倒推”的开发方式，是一种很有效的方法论，叫做“Test Driven Development”，即以测试驱动的开发

测试驱动开发的步骤(以闰年为例)：

* 先假定这个函数写完了，我们需要验证它返回的结果对不对
* 先假定都不是闰年
* 按照对应判断流程进行完成
* 进行优化

### 试错的流程控制

在Python语言中，有专门用来“试错”的流程控制 ———— 今天绝大多数编程语言都有这种“试错语句”。当一个程序执行的时候，有两种错误可能会导致程序执行失败：https://docs.python.org/3/library/exceptions.html

> 语法错误(Syntax Errors)
> 意外(Exceptions)

在Python中，我们可以用`try`语句去执行那些可能出现意外的语句，`try`也可以配合`except`、`else`、`finally`使用。从另外一个角度看，`try`语句块也是一种特殊的流程控制，专注于“当意外发生时应该怎么办？”

所谓测试驱动开发要使用更为强大更为复杂的模块、框架和工具，比如，起码使用Python内建库中的unittest模块

### 所谓聪明

这里是“聪明反被聪明误”的最好示例长期堆积的地方。很多人真的是因为自己很聪明，所以才觉得“没必要麻烦” ———— 就好像当年苏格拉底仗着记忆力无比强大甚至干脆过目不忘于是鄙视一切记笔记的人一样。

但是，随着时间的推移，随着工程量的放大，到最后，那些“聪明人”都被自己坑死了 ———— 聪明本身搞不定工程，能搞定工程的是智慧。苏格拉底自己并没有完成任何工程，是他的学生柏拉图不顾他的嘲笑用纸笔记录了一切；而后柏拉图的学生亚里士多德才有机会受到苏格拉底的启发，写了《前分析篇》，提出对人类影响至今的“三段论”……

## 可执行的Python文件

---

关于`#!/usr/bin/env python`或者`#!/usr/bin/python`

用于在没有在执行程序时指出用什么程序运行py脚本。如上，系统会去调用python程序来执行

> `#!/usr/bin/python`是绝对路径，指去/usr/bin/目录下找python去执行
> `#!/usr/bin/env python`非绝对路径，指在/usr/bin/env中找到Python的安装路径，然后通过安装路径寻找并执行Python

---

### 用main()函数封装：

使用到的原理：

* 当一个模块被`import`语句导入的时候，这个模块的`_name_`就是模块名（例如：'mycode'），同时非函数部分会被执行一次
* 当一个模块被命令行运行的时候，这个模块的`_name_`，就被Python解释器设定为`_main_`

封装方法：

> 建立main函数，将非函数代码放到main函数中运行。并将如下语句作为非函数代码写入模块
> if _name_ == '_main_':
    main()

结果：

1、当Python文件被当做模块，被`import`语句导入时，`if`判断失败，`main()`函数不被执行；
2、当Python文件被`Python -m`运行的时候，`if`判断成功，`main()`函数才被执行

* `Python that.py` == `Python -m that`，有`-m`参数，就不要写文件尾缀`.py`

## 刻意思考

随着时间的推移，你会体会到它的威力：

> 刻意思考哪儿需要刻意练习

只不过是一句话而已，却竟然知道与不知道之间终究会形成天壤之别的差异，也是神奇

刻意思考，就是所谓的琢磨。琢磨这事，一旦开始就简单的要死，可无从下手的时候就神秘无比。让我们再看一个“刻意思考” ———— 即，琢磨 ———— 的应用领域：

> 这东西能用在哪儿呢？

很多人学了却没怎么练，有一个很现实的原因 ———— 没什么地方用得上。

这也怪我们的应试教育，大学前上12年学，“学”的绝大多数东西，只有一个能够切实体会到的用处，考试 ———— 中考、高考，以及以它们为目标的无数“模考”……于是，反过来，不管学什么东西，除了考试之外，几乎无法想象其他的用处。

一旦我们启动了对某项技能的自学之后，在那过程中，最具价值的刻意思考就是，时时刻刻琢磨“这东西能用在哪儿呢？”

比如，当你看到字符串的Methods中有一个 `str.zfill()`的时候，马上就能想到，"恩，这可以用来批量更名文件名……"

虽然现在的 Mac OS 操作系统里已经有相当不错的批量更名工具内建在 Finder 之中，但这是近期才加进去的功能，几年前却没有 ———— 也就是说，几年前的时候，有人可以用 `str.zfill()` 写个简单的程序完成自己的工作，而另外一些人仅因为操作系统没有提供类似的功能就要么手工做，要么干脆忍者忘了算了……

但更多的时候，需要你花时间去琢磨，才能找到用处

找到用处，有时候还真挺难的 ———— 因为人都一样，容易被自己的眼界所限，放眼过去，没有用处，自然也就不用了，甚至不用学了，更不用提那就肯定感觉不用练了……

所以，仔细想想罢 ———— 那些在学校里帮老师干活的小朋友们，更多情况下还真不是很多人以为的“拍马屁”，只不过是在“主动找活干”……

找活干，是应用所学的最有效方式，有活干，所以就有问题需要解决，所以就有问题需要反复攻关，在这个过程中，**以用带练……**

所以，很多人在很多事上都相反了。

人们常常取笑那些呼哧呼哧干活的人，笑着说，“能者多劳”，觉得他们有点傻

这话真的没错 ———— 但这么说更准确：劳者多能 ———— 你看，都相反了吧？

到最后，一切自学能力差的人，外部的表现都差不多，都起码包括这么一条：眼里没活。他们也不喜欢干活，甚至也没想过，玩乐也是干活 ———— 从消耗或者成本的角度来看根本没啥区别 ———— 只不过那些通常都是没有产出的活而已

在最初想不出什么用处的时候，还可以退而求其次，看看“别人想出什么用处没有？” ———— 比如，我去Google`best applications of python skill`,在第一个页面我发现了这么一篇文章："what exactlly can you do with Python?"，翻了一会儿觉得颇有意思……

再高阶一点的刻意思考(琢磨)，无非是在“这东西能用在哪儿呢？”这句话里加上一个字而已：

> 这东西还能用在哪儿呢？

我觉得这个问题对思维训练的帮助非常深刻 ———— 别看只是多了一个字而已。

当我读到在编程的过程中有很多“约定”的时候，就琢磨着：

> * 哦，原来约定如此重要……
> * 哦，原来有那么多人不重视约定……
> * 哦，原来就应该直接过滤掉那些不遵守约定的人…… ———— 那这个原理还能用在哪儿呢？ ———— 哦，在生活中也一样，遇到不遵守约定的人或事，直接过滤，不要浪费自己的生命……

学编程真的很有意思，因为这个领域是世界上最聪明的人群之一开辟出来并不断共同努力着发展的，所以，在这个世界里有很多思考方式，琢磨方式，甚至可以干脆称为“做事哲学”的东西，可以普遍应用在其他领域，甚至其他任何领域

比如，在开发方法论中，有一个叫做 `MoSCoW Method` 的东西，1994年由 Clegg Dai 在《Case Method Fast-Track: A RAD Approach》一书中提出的。

简单说，就是，凡事都可以分为：

> * Must have
> * Should have
> * Could have
> * Won't have

于是，在开发的时候，把所谓的需求打上这4个标签中的某一个，以此分类，就很容易剔除掉那些实际上做了还不如不做的功能……

琢磨一下罢，这个东西还可以用在什么地方？

显然，除了编程之外，其他应用领域还挺多的，这个原则相当的有启发性……

我写书就是这样的。在准备的过程中 ———— 这个过程比绝大多数人想象得长很多 ———— 我会罗列所有我能想到的相关话题……等我觉得已经再也没有什么可补充的时候，再为这些话题写上几句构成大纲……这时候就会发现很多话题其实应该是同一个话题。如此这般，一次扩张，一次收缩之后，就会进行下一步，应用 MoSCoW 原则，给这些话题打上标签 ———— 在这过程中，总是发现很多之前感觉必要的话题，其实可以打上`Won't have`的标签，于是，把它们剔除，然后从 `Must have` 开始写起，直到 `Should have` ，至于 `Could have` 看时间是否允许，看情况，比如看有没有最后期限限制……

在写书这事上，我总是给人感觉很快，事实上也是，因为有方法论 ———— 但显然，那方法论不是从某一本“如何写书”的书里获得的，而是从另外一个看起来完全不相关的领域里习得后琢磨到的……

所谓的“活学活用”，所谓的“触类旁通”，也不过如此。

